var documenterSearchIndex = {"docs":
[{"location":"index.html#Essentia.jl","page":"Index","title":"Essentia.jl","text":"","category":"section"},{"location":"index.html","page":"Index","title":"Index","text":"Documentation for Essentia.jl","category":"page"},{"location":"index.html#Module-Index","page":"Index","title":"Module Index","text":"","category":"section"},{"location":"index.html","page":"Index","title":"Index","text":"Modules = [Essentia]\nOrder   = [:constant, :type, :function, :macro]","category":"page"},{"location":"index.html#Detailed-API","page":"Index","title":"Detailed API","text":"","category":"section"},{"location":"index.html","page":"Index","title":"Index","text":"Modules = [Essentia]\nOrder   = [:constant, :type, :function, :macro]","category":"page"},{"location":"index.html#Essentia.Algorithm","page":"Index","title":"Essentia.Algorithm","text":"Functor representing an algorithm.\n\n\n\nInstantiating\n\nfunction Algorithm(name, params...; type=\"standard\")\n\nThis function returns the algorithm name using essentia::standard or essentia::streaming depending on type. Other arguments can be passed in a key-value fashion.\n\nFields\n\nname::String\ntype::String\nalgo::T\nninp::Int32\nnout::Int32\n\nExample\n\nEssentia.Algorithm(\"MFCC\", :dctType=>3, :logType=\"natural\")\n\n\n\nRunning\n\nfunction (self::Algorithm)(inputs::Pair{String, T}...; force=false) where T\n\nfunction (\n    self::Algorithm)(inputs::Union{AbstractArray{T}, Number, AbstractString}...; force=false) where T\n\nfunction (self::Algorithm)(inputs::Tuple{Vector{Pair}, V}; force=false) where V\n\nfunction (self::Algorithm)()\n\nExecutes the algorithm. Note that while this function is running, the garbage-collector is suspended!\n\nArguments\n\na variadic number of pairs where:\nkeys must be strings with the same name as the Essentia   documentation \nvalues are C++ or Julia objects\n\nOR\n\na variadic number of Julia objects in the same order as Essentia documentation\n\nOR\n\n[meant to be used internally] a Tuple{Vector{Pairs{String, T}}, Vector{V}} where:\npair keys are strings with the same name as Essentia documentation \npair values are C++ objects\nV is a type descriptor\n\nAn optional boolean key force is available for methods 1 and 3; if true, the keys are discarded and values are considered to match the keys in same order as Essentia docs\n\nReturns\n\na Tuple{Vector{Pairs{String, T}}, Vector{V}} where:\npair keys are strings with the same name as Essentia documentation \npair values are C++ objects\nV is a type descriptor\n\nUse jj function to get a dictionary of Julia objects\n\n\n\n\n\n","category":"type"},{"location":"index.html#Essentia.EssentiaComp","page":"Index","title":"Essentia.EssentiaComp","text":"struct EssentiaComp {T}\n    algos::Vector{T}\n    output::Union{Nothing, String}\nend\n\nA functor for composing Algorithm instances.\n\nArguments\n\nalgos should be a Vector{Algorithm} in the order of composition (outer function first)\noutput is the key of the output you want to get\n\nWhen you call, a boolean key force allows to match non-corresponding algorithms (see Algorithm docs).\n\n\n\n\n\n","category":"type"},{"location":"index.html#Essentia.EssentiaException","page":"Index","title":"Essentia.EssentiaException","text":"struct EssentiaException <: Exception\n    message::String\nend\n\nAn exception for something that happens in Essentia \n\n\n\n\n\n","category":"type"},{"location":"index.html#Essentia.Pool","page":"Index","title":"Essentia.Pool","text":"Type definition for representing essentia::Pool using dictionaries, so that:     * keys are always the following:         * 'real'         * 'vectorreal'         * 'string         * 'vectorstring'         * 'matrix'         * 'stereo'         * 'singlereal'         * 'singlevectorreal'         * 'singlestring         * 'singlevectorstring'\n\n* values are `Dict{String, T}` , where `T` changes\n    according to the key (see Pool C++\n    [docs](https://essentia.upf.edu/doxygen/classessentia_1_1Pool.html))\n\nNote that \"stereo\" corresponds to Essentia's StereSample which refer to C++ std::vector<StereoSample> and are converted into Matrix{Float32} in Julia.\n\n\n\n\n\n","category":"type"},{"location":"index.html#Base.convert-Tuple{Type{Dict{String,Dict{String,Union{Float32, Array{Array{Float32,1},1}, Array{Array{Float32,2},1}, Array{Array{String,1},1}, Array{Float32,1}, Array{String,1}, String}}}},Cxx.CxxCore.CppValue{Cxx.CxxCore.CxxQualType{Cxx.CxxCore.CppBaseType{Symbol(\"essentia::Pool\")},(false, false, false)},N} where N}","page":"Index","title":"Base.convert","text":"Convert essentia::Pool to our Pool type.\n\nUsed internally.\n\n\n\n\n\n","category":"method"},{"location":"index.html#Base.convert-Union{Tuple{K}, Tuple{N}, Tuple{L}, Tuple{T}, Tuple{Type{Cxx.CxxCore.CppValue{Cxx.CxxCore.CxxQualType{Cxx.CxxCore.CppTemplate{Cxx.CxxCore.CppBaseType{Symbol(\"std::vector\")},Tuple{Cxx.CxxCore.CppValue{Cxx.CxxCore.CxxQualType{Cxx.CxxCore.CppTemplate{Cxx.CxxCore.CppBaseType{Symbol(\"std::vector\")},Tuple{T,Cxx.CxxCore.CxxQualType{Cxx.CxxCore.CppTemplate{Cxx.CxxCore.CppBaseType{Symbol(\"std::allocator\")},Tuple{T}},(false, false, false)}}},(false, false, false)},L},Cxx.CxxCore.CxxQualType{Cxx.CxxCore.CppTemplate{Cxx.CxxCore.CppBaseType{Symbol(\"std::allocator\")},Tuple{Cxx.CxxCore.CppValue{Cxx.CxxCore.CxxQualType{Cxx.CxxCore.CppTemplate{Cxx.CxxCore.CppBaseType{Symbol(\"std::vector\")},Tuple{T,Cxx.CxxCore.CxxQualType{Cxx.CxxCore.CppTemplate{Cxx.CxxCore.CppBaseType{Symbol(\"std::allocator\")},Tuple{T}},(false, false, false)}}},(false, false, false)},L}}},(false, false, false)}}},(false, false, false)},N}},Array{Array{K,1},1}}} where K where N where L where T","page":"Index","title":"Base.convert","text":"Convert Julia's Vector{Vector{T}} to Essentia's std::vector<std::vector<T>> and vice-versa\n\nUsed internally.\n\n\n\n\n\n","category":"method"},{"location":"index.html#Base.convert-Union{Tuple{K}, Tuple{T}, Tuple{Type{Cxx.CxxCore.CppValue{Cxx.CxxCore.CxxQualType{Cxx.CxxCore.CppTemplate{Cxx.CxxCore.CppBaseType{Symbol(\"TNT::Array2D\")},Tuple{K}},(false, false, false)},N} where N},Array{T,2}}} where K where T","page":"Index","title":"Base.convert","text":"Convert Julia's Matrix{T} to Essentia's Matrix (aka TNT::Array2D) and vice-versa\n\nUsed internally.\n\nN.B. The C++ object is not garbage-collected and some reference to x must exist so that C++ can use the output array. If x doesn't exist, the data are lost.\n\n\n\n\n\n","category":"method"},{"location":"index.html#Base.convert-Union{Tuple{K}, Tuple{T}, Tuple{Type{Cxx.CxxCore.CppValue{Cxx.CxxCore.CxxQualType{Cxx.CxxCore.CppTemplate{Cxx.CxxCore.CppBaseType{Symbol(\"essentia::Tuple2\")},Tuple{K}},(false, false, false)},N} where N},Tuple{T,T}}} where K where T","page":"Index","title":"Base.convert","text":"Convert Julia's Tuple{T} to Essentia's Tuple2<T> and vice-versa\n\nUsed internally.\n\nE.g. StereoSample typedef\n\n\n\n\n\n","category":"method"},{"location":"index.html#Base.convert-Union{Tuple{K}, Tuple{T}, Tuple{Type{Cxx.CxxCore.CppValue{Cxx.CxxCore.CxxQualType{Cxx.CxxCore.CppTemplate{Cxx.CxxCore.CppBaseType{Symbol(\"std::complex\")},Tuple{K}},(false, false, false)},N} where N},Complex{T}}} where K where T","page":"Index","title":"Base.convert","text":"Convert Julia's Complex{T} to C++'s complex<T> and vice-versa\n\nUsed internally.\n\n\n\n\n\n","category":"method"},{"location":"index.html#Base.convert-Union{Tuple{T}, Tuple{K}, Tuple{V}, Tuple{Type{Array{V,2}},Cxx.CxxCore.CppValue{Cxx.CxxCore.CxxQualType{Cxx.CxxCore.CppTemplate{Cxx.CxxCore.CppBaseType{Symbol(\"std::vector\")},Tuple{Cxx.CxxCore.CppValue{Cxx.CxxCore.CxxQualType{Cxx.CxxCore.CppTemplate{Cxx.CxxCore.CppBaseType{Symbol(\"essentia::Tuple2\")},Tuple{K}},(false, false, false)},T},Cxx.CxxCore.CxxQualType{Cxx.CxxCore.CppTemplate{Cxx.CxxCore.CppBaseType{Symbol(\"std::allocator\")},Tuple{Cxx.CxxCore.CppValue{Cxx.CxxCore.CxxQualType{Cxx.CxxCore.CppTemplate{Cxx.CxxCore.CppBaseType{Symbol(\"essentia::Tuple2\")},Tuple{K}},(false, false, false)},T}}},(false, false, false)}}},(false, false, false)},N} where N}} where T where K where V","page":"Index","title":"Base.convert","text":"Convert Julia's Matrix{T} to Essentia's vector<Tuple2<T>> and vice-versa\n\nUsed internally.\n\n\n\n\n\n","category":"method"},{"location":"index.html#Base.convert-Union{Tuple{T}, Tuple{V}, Tuple{Type{Dict{String,T}},Cxx.CxxCore.CppRef{Cxx.CxxCore.CppTemplate{Cxx.CxxCore.CppBaseType{Symbol(\"std::map\")},Tuple{Cxx.CxxCore.CxxQualType{Cxx.CxxCore.CppTemplate{Cxx.CxxCore.CppBaseType{Symbol(\"std::__cxx11::basic_string\")},Tuple{UInt8,Cxx.CxxCore.CxxQualType{Cxx.CxxCore.CppTemplate{Cxx.CxxCore.CppBaseType{Symbol(\"std::char_traits\")},Tuple{UInt8}},(false, false, false)},Cxx.CxxCore.CxxQualType{Cxx.CxxCore.CppTemplate{Cxx.CxxCore.CppBaseType{Symbol(\"std::allocator\")},Tuple{UInt8}},(false, false, false)}}},(false, false, false)},V,Cxx.CxxCore.CxxQualType{Cxx.CxxCore.CppTemplate{Cxx.CxxCore.CppBaseType{Symbol(\"std::less\")},Tuple{Cxx.CxxCore.CxxQualType{Cxx.CxxCore.CppTemplate{Cxx.CxxCore.CppBaseType{Symbol(\"std::__cxx11::basic_string\")},Tuple{UInt8,Cxx.CxxCore.CxxQualType{Cxx.CxxCore.CppTemplate{Cxx.CxxCore.CppBaseType{Symbol(\"std::char_traits\")},Tuple{UInt8}},(false, false, false)},Cxx.CxxCore.CxxQualType{Cxx.CxxCore.CppTemplate{Cxx.CxxCore.CppBaseType{Symbol(\"std::allocator\")},Tuple{UInt8}},(false, false, false)}}},(false, false, false)}}},(false, false, false)},Cxx.CxxCore.CxxQualType{Cxx.CxxCore.CppTemplate{Cxx.CxxCore.CppBaseType{Symbol(\"std::allocator\")},Tuple{Cxx.CxxCore.CxxQualType{Cxx.CxxCore.CppTemplate{Cxx.CxxCore.CppBaseType{Symbol(\"std::pair\")},Tuple{Cxx.CxxCore.CxxQualType{Cxx.CxxCore.CppTemplate{Cxx.CxxCore.CppBaseType{Symbol(\"std::__cxx11::basic_string\")},Tuple{UInt8,Cxx.CxxCore.CxxQualType{Cxx.CxxCore.CppTemplate{Cxx.CxxCore.CppBaseType{Symbol(\"std::char_traits\")},Tuple{UInt8}},(false, false, false)},Cxx.CxxCore.CxxQualType{Cxx.CxxCore.CppTemplate{Cxx.CxxCore.CppBaseType{Symbol(\"std::allocator\")},Tuple{UInt8}},(false, false, false)}}},(true, false, false)},V}},(false, false, false)}}},(false, false, false)}}},(false, false, false)}}} where T where V","page":"Index","title":"Base.convert","text":"Convert C++ std::map<std::string, T> to Dict{String, T} type.\n\nUsed internally.\n\n\n\n\n\n","category":"method"},{"location":"index.html#Essentia.es2julia-Union{Tuple{T}, Tuple{T,String}} where T","page":"Index","title":"Essentia.es2julia","text":"function es2julia(d::T, type_str::String) where T\n\nPerform conversion from a C++ pointer to Julia according to the description in type_str (returned by typeInfoToStr)\n\nThe return type changes according to type_str, so this function is NOT guaranteed to be type coherent, even though it should be so.\n\n\n\n\n\n","category":"method"},{"location":"index.html#Essentia.jj-Union{Tuple{Tuple{Array{Pair,1},V}}, Tuple{V}} where V","page":"Index","title":"Essentia.jj","text":"function jj(objects::Tuple{Vector{Pair}, V})::Dict where V\n\nTakes the output of an Algorithm and converts them to Julia dictionary so that:     * keys are strings with the names in Essentia documentation      * values are Julia objects\n\nIf no conversion is implemented, then the Cxx object wrapping the C++ type is returned. When working with Pool, expect to receive a Cxx object and to work with icxx macro.\n\n\n\n\n\n","category":"method"},{"location":"index.html#Essentia.julia2es_number-Tuple{Type}","page":"Index","title":"Essentia.julia2es_number","text":"function julia2es(d::T) where T\n\nPerform conversion from Julia to Essentia types.\n\nNote that in essentia, strings are threated as std::string, while icxx converts them; for this reason, you need to use this function to deal with Essentia's strings.\n\nThe return type changes according to T, so this function is type coherent\n\n\n\n\n\n","category":"method"},{"location":"index.html#Essentia.rollup-Union{Tuple{K}, Tuple{T}, Tuple{Type{T},Function,AbstractArray{K,N} where N,Integer,Integer}, Tuple{Type{T},Function,AbstractArray{K,N} where N,Integer,Integer,String}, Tuple{Type{T},Function,AbstractArray{K,N} where N,Integer,Integer,String,Real}} where K<:Number where T","page":"Index","title":"Essentia.rollup","text":"function rollup(::Type{T},\n                fn::Function,\n                z::AbstractArray{K},\n                ws::Integer,\n                hs::Integer,\n                padding::String=\"minimum\",\n                padding_fill::Real=0.0) where {T, K<:Number}\n\nExecute a function over frames extracted as views of an array\n\nArguments\n\nT: the type returned by fn\nfn: a function accepting a frame – i.e. an n-dimensional Array – e.g. an Algorithm\nz: a n-dimensional Array from which each frame is extracted; frames are extracted along rows.   For instance, let A be a 5×2 array (5 samples and 2 features), and ws=3, hs=2;   this function extracts frames in this way:       ```julia       julia> A = reshape(collect(1:10), 5, 2)       5×2 Array{Int64,2}:        1   6        2   7        3   8        4   9        5  10\n  julia> selectdim(A, 1, 1:3)\n  3×2 view(::Array{Int64,2}, 1:3, :) with eltype Int64:\n   1  6\n   2  7\n   3  8\n\n  julia> selectdim(A, 1, 3:5)\n  3×2 view(::Array{Int64,2}, 3:5, :) with eltype Int64:\n   3   8\n   4   9\n   5  10\n  ```\nws: window size\nhs: hop-size\npadding: a string with the following possible values:\nnone: no padding is added and z is shortened to the biggest number   multiple of ws and ≤ length(z)\nminimum: z is padded both left and right with the minimum size needed to    toll over all the samples\npadding_fill: a value of type K with which z is padded\n\nTo get custom paddings, consider using the PaddedViews package or the FrameCutter algorithm\n\nReturns\n\nif T <: AbstractArray, an Array{T} with one more dimension than the output of fn. \nelse Vector{T}\n\nEach row is the output of a frame.\n\n\n\n\n\n","category":"method"},{"location":"index.html#Essentia.setCppOutput!-NTuple{5,Any}","page":"Index","title":"Essentia.setCppOutput!","text":"function setCppOutput!(outputs, algo, name, type_info, i)\n\nGiven a type_info C++ structure, allocates the corresponding object and set the output of algo\n\n\n\n\n\n","category":"method"},{"location":"index.html#Essentia.typeInfoToStr-Tuple{Any}","page":"Index","title":"Essentia.typeInfoToStr","text":"function typeInfoToStr(type_info_ptr)::String\n\nGiven a type_info * C++ structure, returns a string which describes it (as Essentia Python bindings)\n\n\n\n\n\n","category":"method"},{"location":"index.html#Essentia.@es-Tuple","page":"Index","title":"Essentia.@es","text":"A simple macro which expands this:\n\n@es algo1 algo2 \"output\"\n@es algo1 algo2\n\ninto this:\n\nEssentiaComp([algo2, algo1], \"output\")\nEssentiaComp([algo2, algo1], nothing)\n\nNote the inverse order of the algorithms, that is:\n\nIn EssentiaComp, the algorithms appear in the same order you would write them to compose functions (i.e. outer function first)\nIn es algorithms appear in the order they are computed (i.e. outer function last)\n\nFor now, force=true always here\n\n\n\n\n\n","category":"macro"}]
}
